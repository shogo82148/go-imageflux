package imageflux

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"strings"
	"sync"
	"time"
)

var bufPool = sync.Pool{
	New: func() interface{} {
		buf := make([]byte, 0, 32)
		return &buf
	},
}

// Image is an image served via ImageFlux.
type Image struct {
	// Path is the path of the image.
	Path string

	// Proxy is the proxy server.
	Proxy *Proxy

	// Config is the configuration of
	// converting the image.
	Config *Config

	// Expires is the expiration time of the url
	// generated by String and SignedURL.
	// If Expires is zero, the url does not expire.
	Expires time.Time
}

// SignedURL returns the URL of the image with the signature.
func (img *Image) SignedURL() string {
	path, s := img.pathAndSign(false)
	if s == "" {
		return "https://" + img.Proxy.Host + path
	}
	return "https://" + img.Proxy.Host + "/c/sig=" + s + "," + strings.TrimPrefix(path, "/c/")
}

// SignedURLWithoutComma is same as SignedURL but
// the url doesn't contain comma.
// It is useful for srcset of HTML img tag.
func (img *Image) SignedURLWithoutComma() string {
	path, s := img.pathAndSign(true)
	if s == "" {
		return "https://" + img.Proxy.Host + path
	}
	return "https://" + img.Proxy.Host + "/c/sig=" + s + "%2C" + strings.TrimPrefix(path, "/c/")
}

// Sign returns the signature.
func (img *Image) Sign() string {
	_, s := img.pathAndSign(false)
	return s
}

func (img *Image) pathAndSign(escapeComma bool) (string, string) {
	pbuf := bufPool.Get().(*[]byte)
	buf := (*pbuf)[:0]
	buf = append(buf, "/c/"...)
	buf = img.Config.append(buf, escapeComma)
	if !img.Expires.IsZero() {
		buf = append(buf, ",expires="...)
		buf = img.Expires.UTC().AppendFormat(buf, time.RFC3339)
	}
	if len(img.Path) == 0 || img.Path[0] != '/' {
		buf = append(buf, '/')
	}
	buf = append(buf, img.Path...)
	path := string(buf)

	if img.Proxy.Secret == "" {
		*pbuf = buf
		bufPool.Put(pbuf)
		return path, ""
	}

	mac := hmac.New(sha256.New, []byte(img.Proxy.Secret))
	mac.Write(buf)
	buf = mac.Sum(buf[:0])
	buf2 := make([]byte, len("1.")+base64.URLEncoding.EncodedLen(len(buf)))
	buf2[0] = '1'
	buf2[1] = '.'
	base64.URLEncoding.Encode(buf2[2:], buf)

	*pbuf = buf
	bufPool.Put(pbuf)
	return path, string(buf2[:])
}

// String returns the URL of the image without the signature.
func (img *Image) String() string {
	pbuf := bufPool.Get().(*[]byte)
	buf := (*pbuf)[:0]

	buf = append(buf, "https://"...)
	buf = append(buf, img.Proxy.Host...)
	buf = append(buf, "/c/"...)
	buf = img.Config.append(buf, false)
	if !img.Expires.IsZero() {
		buf = append(buf, ",expires="...)
		buf = img.Expires.UTC().AppendFormat(buf, time.RFC3339)
	}
	if len(img.Path) == 0 || img.Path[0] != '/' {
		buf = append(buf, '/')
	}
	buf = append(buf, img.Path...)
	str := string(buf)
	*pbuf = buf
	bufPool.Put(pbuf)
	return str
}
